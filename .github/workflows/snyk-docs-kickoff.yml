name: Snyk Docs Kickoff Agent

on:
  pull_request:
    types: [opened, edited, synchronize, reopened, ready_for_review, labeled, unlabeled]
  pull_request_target:
    types: [opened, edited, synchronize, reopened, ready_for_review, labeled, unlabeled]

permissions:
  contents: read
  issues: write
  pull-requests: read

jobs:
  kickoff:
    if: ${{ github.event_name == 'pull_request' && github.repository_owner == 'VeronicaSnyk' && !contains(join(github.event.pull_request.labels.*.name, ','), 'docs-agent:off') }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Vale
        run: |
          set -euo pipefail
          VERSION=2.27.0
          curl -sSL -o vale.tar.gz https://github.com/errata-ai/vale/releases/download/v${VERSION}/vale_${VERSION}_Linux_64-bit.tar.gz
          tar -xzf vale.tar.gz
          sudo mv vale /usr/local/bin/vale
          vale --version

      - name: Get changed doc files
        id: changed
        uses: tj-actions/changed-files@v45
        with:
          files: |
            **/*.md
            **/*.mdx
            **/*.adoc
            **/*.txt
            docs/**
            help/**
            **/content/**

      - name: Run Vale on changed docs
        if: ${{ steps.changed.outputs.all_changed_files != '' }}
        run: |
          set -euo pipefail
          printf "%s\n" "${{ steps.changed.outputs.all_changed_files }}" > changed.txt
          tr '\n' '\0' < changed.txt | xargs -0 -r vale --output=JSON --no-exit > vale-results.json || true

      - name: Post kickoff guidance
        uses: actions/github-script@v7
        env:
          GITBOOK_API_KEY: ${{ secrets.GITBOOK_API_KEY }}
          DOCS_AGENT_DRY_RUN: ${{ vars.DOCS_AGENT_DRY_RUN || '' }}
          GITBOOK_MCP_ENDPOINT: ${{ vars.GITBOOK_MCP_ENDPOINT || '' }}
        with:
          script: |
            const fs = require('fs');
            const pr = context.payload.pull_request;
            if (!pr) {
              core.info('Not a pull_request event.');
              return;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = pr.number;

            const defaultMcpEndpoint = 'https://app.gitbook.com/o/-M4tdxG8qotLgGZnLpFR/s/-MdwVZ6HOZriajCf5nXH//~gitbook/mcp';
            const mcpEndpoint = process.env.GITBOOK_MCP_ENDPOINT || defaultMcpEndpoint;
            const styleGuidePath = 'writing-rules-style-guide.md';
            const styleGuideUrl = `https://github.com/${owner}/${repo}/blob/${pr.base.ref}/${styleGuidePath}`;

            const isDryRun = (String(process.env.DRY_RUN || '').trim() === '1')
              || (String(process.env.DOCS_AGENT_DRY_RUN || '').trim() === '1')
              || !!process.env.ACT;

            // Fetch changed files (first 100 per page, then paginate)
            let files = [];
            if (!isDryRun) {
              files = await github.paginate(
                github.rest.pulls.listFiles,
                { owner, repo, pull_number: issue_number, per_page: 100 }
              );
            } else {
              core.info('DRY_RUN is enabled; skipping network calls to list changed files.');
            }

            const isDocLike = (f) => {
              const docExt = /\.(md|mdx|adoc|txt|rst|mkdn|mkd)$/i;
              return docExt.test(f.filename)
                || f.filename.startsWith('docs/')
                || f.filename.startsWith('help/')
                || f.filename.includes('/docs/')
                || f.filename.includes('/content/');
            };

            const docFiles = files.filter(isDocLike);

            const suggestTitle = (title) => {
              if (!title) return '';
              let s = String(title).replace(/^(wip|draft)[:\-\s]+/i, '').trim();
              s = s.replace(/\s+/g, ' ');
              s = s.replace(/[.!?]$/, '');
              if (s.length > 80) {
                const cut = s.indexOf(':') > 0 ? s.indexOf(':') : (s.indexOf(' - ') > 0 ? s.indexOf(' - ') : 80);
                s = s.slice(0, Math.max(40, cut)).trim();
              }
              s = s.charAt(0).toUpperCase() + s.slice(1);
              return s;
            };

            const sampleList = (arr) => arr.slice(0, 12).map(f => `- ${f.filename} (${f.status})`).join('\n') || '- None detected.';

            const suggestedTitle = suggestTitle(pr.title || '');

            const lines = [];
            const markerHeader = '### Snyk Docs Kickoff Agent';

            lines.push(markerHeader);
            lines.push('');
            lines.push('Early guidance to align your PR with Snyk Docs. Non-blocking; will update on new commits.');
            lines.push('');

            lines.push('#### Suggested PR title');
            if (suggestedTitle && suggestedTitle !== pr.title) {
              lines.push(`- ${suggestedTitle}`);
            } else {
              lines.push('- Title looks reasonable. Consider imperative mood and keeping it concise.');
            }
            lines.push('');

            lines.push('#### Description checklist');
            lines.push('- [ ] State the user goal and summarize what changed.');
            lines.push('- [ ] Clarify product/feature names and link to authoritative docs.');
            lines.push('- [ ] Note breaking changes or migration steps, if any.');
            lines.push('- [ ] Add screenshots/previews for UI/docs pages when helpful.');
            lines.push('- [ ] Include release note if externally visible.');
            lines.push('');

            lines.push('#### Detected doc-related files');
            lines.push(sampleList(docFiles));
            lines.push('');

            try {
              if (fs.existsSync('vale-results.json')) {
                const raw = fs.readFileSync('vale-results.json', 'utf8');
                if (raw && raw.trim().length > 0) {
                  const parsed = JSON.parse(raw);
                  const flatten = (data) => {
                    if (Array.isArray(data)) return data;
                    const out = [];
                    for (const [p, arr] of Object.entries(data || {})) {
                      (arr || []).forEach(it => out.push({ Path: p, ...it }));
                    }
                    return out;
                  };
                  const findings = flatten(parsed).filter(Boolean);
                  const bySeverityRank = { error: 0, warning: 1, suggestion: 2, info: 3 };
                  findings.sort((a, b) => (bySeverityRank[(a.Severity||'').toLowerCase()] ?? 9) - (bySeverityRank[(b.Severity||'').toLowerCase()] ?? 9));

                  lines.push('#### Style findings (Vale)');
                  if (findings.length === 0) {
                    lines.push('- No style issues detected in changed docs.');
                  } else {
                    const maxItems = 12;
                    findings.slice(0, maxItems).forEach(f => {
                      const sev = (f.Severity || '').toString();
                      const rule = f.Check || f.Rule || 'rule';
                      const msg = (f.Message || '').toString().replace(/\s+/g, ' ').trim();
                      const line = f.Line || (f.Span && f.Span[0] ? f.Span[0].Line : undefined) || '';
                      lines.push(`- ${f.Path}${line ? ':'+line : ''} [${sev}] ${rule} — ${msg}`);
                    });
                    if (findings.length > maxItems) {
                      lines.push(`- ...and ${findings.length - maxItems} more.`);
                    }
                  }
                  lines.push('');
                }
              }
            } catch (e) {
              core.warning(`Failed to read Vale results: ${e?.message || e}`);
            }

            // Vale findings (if produced by a previous step)
            try {
              if (fs.existsSync('vale-results.json')) {
                const raw = fs.readFileSync('vale-results.json', 'utf8');
                if (raw && raw.trim().length > 0) {
                  const parsed = JSON.parse(raw);
                  const flatten = (data) => {
                    if (Array.isArray(data)) return data;
                    const out = [];
                    for (const [path, arr] of Object.entries(data || {})) {
                      (arr || []).forEach(it => out.push({ Path: path, ...it }));
                    }
                    return out;
                  };
                  const findings = flatten(parsed).filter(Boolean);
                  const bySeverityRank = { error: 0, warning: 1, suggestion: 2, info: 3 };
                  findings.sort((a, b) => (bySeverityRank[(a.Severity||'').toLowerCase()] ?? 9) - (bySeverityRank[(b.Severity||'').toLowerCase()] ?? 9));

                  lines.push('#### Style findings (Vale)');
                  if (findings.length === 0) {
                    lines.push('- No style issues detected in changed docs.');
                  } else {
                    const maxItems = 12;
                    findings.slice(0, maxItems).forEach(f => {
                      const sev = (f.Severity || '').toString();
                      const rule = f.Check || f.Rule || 'rule';
                      const msg = (f.Message || '').toString().replace(/\s+/g, ' ').trim();
                      const line = f.Line || (f.Span && f.Span[0] ? f.Span[0].Line : undefined) || '';
                      lines.push(`- ${f.Path}${line ? ':'+line : ''} [${sev}] ${rule} — ${msg}`);
                    });
                    if (findings.length > maxItems) {
                      lines.push(`- ...and ${findings.length - maxItems} more.`);
                    }
                  }
                  lines.push('');
                }
              }
            } catch (e) {
              core.warning(`Failed to read Vale results: ${e?.message || e}`);
            }

            lines.push('#### Terminology and style');
            lines.push('- Use consistent product names (for example, "Snyk Open Source", "Snyk Code", "Snyk IaC").');
            lines.push('- Prefer active voice and imperative titles.');
            lines.push('- Use American English spelling.');
            lines.push('- Use code formatting for CLI, API names, and file paths.');
            lines.push('');

            lines.push('#### Style guide links');
            if (process.env.GITBOOK_API_KEY) {
              lines.push('- Style‑guide integration detected. Citations will be added in a subsequent iteration of this pilot.');
            } else {
              lines.push('- Add the repository secret `GITBOOK_API_KEY` to enable style‑guide citations from GitBook.');
            }
            lines.push(`- Snyk writing rules & style guide: [${styleGuidePath}](${styleGuideUrl})`);
            lines.push(`- MCP endpoint: ${mcpEndpoint}`);
            lines.push('');

            lines.push('_Add the label `docs-agent:off` to silence this comment._');

            const body = lines.join('\n');

            if (isDryRun) {
              core.info('DRY_RUN=1 set; not posting to GitHub.\n----- Kickoff comment preview -----\n' + body + '\n----------------------------------');
              return;
            }

            // Upsert sticky comment
            const { data: comments } = await github.rest.issues.listComments({ owner, repo, issue_number, per_page: 100 });
            const existing = comments.find(c => typeof c.body === 'string' && c.body.includes(markerHeader));

            if (existing) {
              if ((existing.body || '').trim() === body.trim()) {
                core.info('Kickoff comment unchanged; skipping update.');
              } else {
                await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
                core.info(`Updated kickoff comment #${existing.id}`);
              }
            } else {
              const created = await github.rest.issues.createComment({ owner, repo, issue_number, body });
              core.info(`Created kickoff comment #${created.data.id}`);
            }

  kickoff_fork:
    name: Snyk Docs Kickoff Agent (Fork PRs)
    if: ${{ github.event_name == 'pull_request_target' && github.repository_owner == 'VeronicaSnyk' && github.event.pull_request.head.repo.owner.login != github.repository_owner && !contains(join(github.event.pull_request.labels.*.name, ','), 'docs-agent:off') }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout base (safe)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.sha }}

      - name: Setup Vale
        run: |
          set -euo pipefail
          VERSION=2.27.0
          curl -sSL -o vale.tar.gz https://github.com/errata-ai/vale/releases/download/v${VERSION}/vale_${VERSION}_Linux_64-bit.tar.gz
          tar -xzf vale.tar.gz
          sudo mv vale /usr/local/bin/vale
          vale --version

      - name: Prepare changed doc files (API)
        id: prep
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = require('path');
            const pr = context.payload.pull_request;
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const files = await github.paginate(
              github.rest.pulls.listFiles,
              { owner, repo, pull_number: pr.number, per_page: 100 }
            );
            const isDocLike = (f) => {
              const docExt = /\.(md|mdx|adoc|txt|rst|mkdn|mkd)$/i;
              return docExt.test(f.filename)
                || f.filename.startsWith('docs/')
                || f.filename.startsWith('help/')
                || f.filename.includes('/docs/')
                || f.filename.includes('/content/');
            };
            const docFiles = files.filter(isDocLike).map(f => f.filename);
            await fs.promises.writeFile('changed.txt', docFiles.join('\n'), 'utf8');
            for (const file of docFiles) {
              try {
                const { data } = await github.rest.repos.getContent({ owner, repo, path: file, ref: pr.head.sha });
                const content = Buffer.from(data.content || '', 'base64').toString('utf8');
                await fs.promises.mkdir(path.dirname(file), { recursive: true });
                await fs.promises.writeFile(file, content, 'utf8');
              } catch (e) {
                core.warning(`Failed to fetch ${file}: ${e?.message || e}`);
              }
            }

      - name: Run Vale on fetched docs
        if: ${{ hashFiles('changed.txt') != '' }}
        run: |
          set -euo pipefail
          tr '\n' '\0' < changed.txt | xargs -0 -r vale --output=JSON --no-exit > vale-results.json || true

      - name: Post kickoff guidance (fork-safe)
        uses: actions/github-script@v7
        env:
          GITBOOK_API_KEY: ${{ secrets.GITBOOK_API_KEY }}
          DOCS_AGENT_DRY_RUN: ${{ vars.DOCS_AGENT_DRY_RUN || '' }}
          GITBOOK_MCP_ENDPOINT: ${{ vars.GITBOOK_MCP_ENDPOINT || '' }}
        with:
          script: |
            const fs = require('fs');
            const pr = context.payload.pull_request;
            if (!pr) {
              core.info('Not a pull_request_target event.');
              return;
            }

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const issue_number = pr.number;

            const defaultMcpEndpoint = 'https://app.gitbook.com/o/-M4tdxG8qotLgGZnLpFR/s/-MdwVZ6HOZriajCf5nXH//~gitbook/mcp';
            const mcpEndpoint = process.env.GITBOOK_MCP_ENDPOINT || defaultMcpEndpoint;
            const styleGuidePath = 'writing-rules-style-guide.md';
            const styleGuideUrl = `https://github.com/${owner}/${repo}/blob/${pr.base.ref}/${styleGuidePath}`;

            const isDryRun = (String(process.env.DRY_RUN || '').trim() === '1')
              || (String(process.env.DOCS_AGENT_DRY_RUN || '').trim() === '1')
              || !!process.env.ACT;

            // NOTE: Do not checkout fork code. Use API-only to list files.
            let files = [];
            if (!isDryRun) {
              files = await github.paginate(
                github.rest.pulls.listFiles,
                { owner, repo, pull_number: issue_number, per_page: 100 }
              );
            } else {
              core.info('DRY_RUN is enabled; skipping network calls to list changed files.');
            }

            const isDocLike = (f) => {
              const docExt = /\.(md|mdx|adoc|txt|rst|mkdn|mkd)$/i;
              return docExt.test(f.filename)
                || f.filename.startsWith('docs/')
                || f.filename.startsWith('help/')
                || f.filename.includes('/docs/')
                || f.filename.includes('/content/');
            };

            const docFiles = files.filter(isDocLike);

            const suggestTitle = (title) => {
              if (!title) return '';
              let s = String(title).replace(/^(wip|draft)[:\-\s]+/i, '').trim();
              s = s.replace(/\s+/g, ' ');
              s = s.replace(/[.!?]$/, '');
              if (s.length > 80) {
                const cut = s.indexOf(':') > 0 ? s.indexOf(':') : (s.indexOf(' - ') > 0 ? s.indexOf(' - ') : 80);
                s = s.slice(0, Math.max(40, cut)).trim();
              }
              s = s.charAt(0).toUpperCase() + s.slice(1);
              return s;
            };

            const sampleList = (arr) => arr.slice(0, 12).map(f => `- ${f.filename} (${f.status})`).join('\n') || '- None detected.';

            const suggestedTitle = suggestTitle(pr.title || '');

            const lines = [];
            const markerHeader = '### Snyk Docs Kickoff Agent';

            lines.push(markerHeader);
            lines.push('');
            lines.push('Early guidance to align your PR with Snyk Docs. Non-blocking; will update on new commits.');
            lines.push('');

            lines.push('#### Suggested PR title');
            if (suggestedTitle && suggestedTitle !== pr.title) {
              lines.push(`- ${suggestedTitle}`);
            } else {
              lines.push('- Title looks reasonable. Consider imperative mood and keeping it concise.');
            }
            lines.push('');

            lines.push('#### Description checklist');
            lines.push('- [ ] State the user goal and summarize what changed.');
            lines.push('- [ ] Clarify product/feature names and link to authoritative docs.');
            lines.push('- [ ] Note breaking changes or migration steps, if any.');
            lines.push('- [ ] Add screenshots/previews for UI/docs pages when helpful.');
            lines.push('- [ ] Include release note if externally visible.');
            lines.push('');

            lines.push('#### Detected doc-related files');
            lines.push(sampleList(docFiles));
            lines.push('');

            lines.push('#### Terminology and style');
            lines.push('- Use consistent product names (for example, "Snyk Open Source", "Snyk Code", "Snyk IaC").');
            lines.push('- Prefer active voice and imperative titles.');
            lines.push('- Use American English spelling.');
            lines.push('- Use code formatting for CLI, API names, and file paths.');
            lines.push('');

            lines.push('#### Style guide links');
            if (process.env.GITBOOK_API_KEY) {
              lines.push('- Style‑guide integration detected. Citations will be added in a subsequent iteration of this pilot.');
            } else {
              lines.push('- Add the repository secret `GITBOOK_API_KEY` to enable style‑guide citations from GitBook.');
            }
            lines.push(`- Snyk writing rules & style guide: [${styleGuidePath}](${styleGuideUrl})`);
            lines.push(`- MCP endpoint: ${mcpEndpoint}`);
            lines.push('');

            lines.push('_Add the label `docs-agent:off` to silence this comment._');

            const body = lines.join('\n');

            if (isDryRun) {
              core.info('DRY_RUN=1 set; not posting to GitHub.\n----- Kickoff comment preview -----\n' + body + '\n----------------------------------');
              return;
            }

            // Upsert sticky comment
            const { data: comments } = await github.rest.issues.listComments({ owner, repo, issue_number, per_page: 100 });
            const existing = comments.find(c => typeof c.body === 'string' && c.body.includes(markerHeader));

            if (existing) {
              if ((existing.body || '').trim() === body.trim()) {
                core.info('Kickoff comment unchanged; skipping update.');
              } else {
                await github.rest.issues.updateComment({ owner, repo, comment_id: existing.id, body });
                core.info(`Updated kickoff comment #${existing.id}`);
              }
            } else {
              const created = await github.rest.issues.createComment({ owner, repo, issue_number, body });
              core.info(`Created kickoff comment #${created.data.id}`);
            }
